#### Запуск сервиса
```shell
Какой самый эффективный способ конкатенации строк?
Самым эффективным способом конкатенации строк считается использование strings.Builder

package main

import (
	"fmt"
	"strings"
)

var str strings.Builder

func main() {
	str.WriteString("Hello, ")
	str.WriteString("Gopher!")
	fmt.Println(str.String())
}


```
```shell
Что такое интерфейсы, как они применяются в Go?

Интерфейсы - это некий контракт, который говорит обьекту, какие методы ему нужно реализвать, чтобы удовлетворять интерфейсу.
Интерфейсы применяются повсеместно. Интерфейсы позволяют определять функции, которые не привязаны к конкретной реализации, то есть интерфейсы определяют некий функционал, но не реализуют его.

```
```shell
Чем отличаются RWMutex от Mutex?

RWMutex концептуально то же самое, что и Mutex: он защищает доступ к памяти. Тем не менее, RWMutex дает немного больше контроля над памятью. Можно запросить блокировку для чтения, и в этом случае будет предоставлен доступ, если блокировка не удерживается для записи.
```
```shell
Чем отличаются буферизированные и не буферизированные каналы?
Буферизированные каналы, как ни странно имеют буфер :) Буферизированный канал не блокируется до тех пор, пока есть место в буфере. Горутины, которые поступают в буфер следуют принципу FIFO (первая вошла, первая вышла)
```
```shell
Какой размер у структуры struct{}{}?
Если мы вызовем метод Sizeof из пакета unsafe, то получим:

package main

import (
	"fmt"
	"unsafe"
)

func main() {
	Struct := struct{}{}
	fmt.Printf("Size is %v\n", unsafe.Sizeof(Struct))
}
Вывод:
Size is 0
Но стоит также учитывать то, что расходуется память на обьявление структуры, хранение указателя и.т.д
Но сама структура занимает 0 байт, ведь это просто абстракция.
```
```shell
Есть ли в Go перегрузка методов или операторов?
Нет, в Go отстутствует перегрузка методов и операторов, в том понимание, в котором она должна быть реализована. Можно использовать интерфейсы, обьявлять разные обьекты с тем же названием функций.
```
```shell
В какой последовательности будут выведены элементы map[int]int?

Пример:
m[0]=1
m[1]=124
m[2]=281

В случайной последовательности, т.к реализацией мапы внутри го является hash-функция
```
```shell
В чем разница make и new?
Во-первых реализацией:
var a = new(T) // a имеет тип *T после обьявляения

var a = make([]T, l, c) // l - размер, c - емкость
В функцию make первый аргументом должен быть либо слайс, мапа, или канал, а функция new выделяет память для переменной любого типа(возвращает указатель на нулевое значение этого типа)
Функцию make можно использовать без двух последних аргументов, в таком случае она выделит небольшой размер памяти.
Make возвращает экземпляр самого типа данных, а не указатель на него.

```
```shell
Сколько существует способов задать переменную типа slice или map?
Для slice:
1) функция make([]int)
2) функция new([]int)
3) var s []int
4) s := []int{}
5) s := baseArray[0:1] || [:]
6) В пакете sort есть типы IntSlice, StringSlice и.т.д

Для map:
1)make(map[int]int)
2)new(map[int]int)
3)var m map[int]int
4)m := map[int]int{}

Следовательно для slice и для map сущетсвует 6 и 4 способов соответсвенно задать переменную.
```
```shell
Что выведет данная программа и почему?

func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}

Так как в Го переданное в фукнцию значение всегда копируется, даже если это ссылка (ссылка тоже копируется),
то в функции update мы просто присвоили локальной переменной p адрес локальной переменной b, следовательно,
Вывод будет:
1
1
Так как в main функции p все еще указывает на переменную a.

```
```shell
Что выведет данная программа и почему?

func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}

Вывод:
На самом деле вывод цифр будет разным в разный момент времени, т.к функция выполняется асинхронно.
4 
0
1
3
2
fatal error: all goroutines are asleep - deadlock!
Паника произойдет из-за того, что мы передаем структуру WaitGroup по значению, и она копируется по значению, следоватлеьно счетчик декрементируется локально, и когда дойдем до wg.Waut() горутина main остановится.
Исправленная функция:

func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg *sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(&wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
Теперь вывод:
4
0
1
2
3
exit

```
```shell
Что выведет данная программа и почему?

func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
Вывод:
0
Так как инкрементировалась теневая переменная n в области видимости if,
а не переменная n области видимости main функции.
```
```shell
Что выведет данная программа и почему?

func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
Вывод:
[100 2 3 4 5]
Так как слайс представляет из себя структуру,
c полями:
    1) Указатель на базовый массив
    2) Длина слайса
    3) Capacity
, то следовательно мы можем изменять элементы слайса, так как переданный указатель указывает на ту же область памяти
что и исходный, но вод сделать append уже не получится (для передаваемого слайса), так как длина и капасити изменяется только локально.
```
```shell
Что выведет данная программа и почему?


func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}

```
